Часть 1. Теория и опыт. Оценочное время 15 минут.
Требуется письменно ответить на вопросы.
 
1) Описать подход и ориентировочный алгоритм решения задачи. Клиенту необходимо запросить отчет в личном кабинете сервиса за последние 10 лет единым документом. Время формирования отчета не менее 5 минут. Как организовать процесс так, чтобы клиент не ждал эти 5 минут загрузки страницы и остался “доволен” результатом. Какие принципы и технологии обычно используются? Привести примеры.

Отдаем клиенту страницу сразу, показываем прелоадер, на сервере стартуем процесс формирования отчета, на клиенте стартуем процесс опрашивающий о статусе готовности отчета. По завершению отдаем клиенту документ. Это, если отчет необходим по требованию. Решение можно улучшить, если знать некоторые подробности. Например, можно использовать queue, stack и т.д. если отчет часто формируется пользователями. Если один отчет может использоваться несколькими пользователями и актуальность не сильно критична, например, подойдет вчерашний или сгенерированный неделю назад, то можно сохранять результат построения отчета и предлагать пользователю использовать готовый отчет. Если ессть известный период обновления отчета (каждое 20-е число или каждый день), то можно добавить задачу в планировщик (cron и т.д.). Так же можно предложить пользователю получить отчет иным способом (ссылка на почту, в мессенджер и т.д.).
 
2) Имеется проблемная страница сайта с временем загрузки 10 секунд. Опишите ориентировочную последовательность действий, подход, сервисы, инструменты необходимые для решения проблемы в целом. Что наиболее приоритетно, что менее приоритетно? Задачу можно разбить по специалистам в условной команде, если требуется.

Если проблема связана с клиентской частью (статикой, css, js и т.д.) нам помогут:
lighthouse аудит (https://developers.google.com/web/tools/lighthouse/).
Так же смотрим на timeline вкладки network в chrome-devtools. Обращаем внимание на параметр Waiting (TTFB).

Если проблема со стороны сервера, запускаем профилировщик:
yii2-debug (сразу смотрим timeline),xdebug
Локализуем узкие места.

Еще полезный инструмент:
https://developers.google.com/speed/?hl=ru-RU&utm_source=PSI&utm_medium=incoming-link&utm_campaign=PSI

 
3) В Yii2 каждый файл конфигурации хранится в двух видах. Зачем так сделано и как эти файлы ведут себя в git?
Не понял, о каких видах идет речь, но предполагаю, что вопрос о конфигурации под окружение. Поэтому отвечу так: Для того, чтоб была возможность переопределять свойства приложения в зависимости от окружения. В git локальная конфигурация, как правило, игнорируется. А вообше, как настроишь. Может быть, например не "два вида", а больше, да и в git могут попадать локальные конфигурации, если используется автоматический деплой или какой-нибудь docker container, lxc, vagrant для локальной разработки. А если еще учесть, что может быть какая-то оркестрация хитрая, то очевидно ответить, как они себя ведут нельзя.

4) Представим сервис, на котором постоянно происходит много регистраций по указанному email. Как наиболее корректно и достоверно проверять указанный email на валидность? 
Использовать email валидатор. Так же можно добавить шаг с последующей верефикацией email, если это допустимо.

Часть 2 (опционально). Практика программирования. Оценочное время 60 минут.
 
Результат всех заданий разместить на github и выслать ссылку.
 
1. Используя Yii2 необходимо реализовать форму регистрации пользователя с условием типа физ./юр. лицо. Для физ. лица необходимо заполнить: почту, ФИО и в случае ИП - ИНН, а для юр. лица: почту, ФИО, название организации и инн.

Тут можно было прикрутить валидатор ИНН, но я не стал это делать, т.к. это - тестовое задание


Внешний вид значения не имеет.
 
2. Реализовать кеширование для функции:
```
function($date, $type) {
    $userId = Yii::$app->user->id;
    $dataList = SomeDataModel::find()->where(['date' => $date, 'type' => $type, 'user_id' => $userId])->all();
    $result = [];
 
    if (!empty($dataList)) {
        foreach ($dataList as $dataItem) {
            $result[$dataItem->id] = ['a' => $dataItem->a, 'b' => $dataItem->b];
        }
    }
 
    return $result;
}
``` 

Решение:
```
<?php

function($date, $type, $cache) {
    $userId = Yii::$app->user->id;

    $key = $userId.'_'.$type.'_'.$date  
    
    $result = ($cache->get($key)) ? return $cache->get($key): $result = [];

    $dataList = SomeDataModel::find()->where(['date' => $date, 'type' => $type, 'user_id' => $userId])->all();
 
    if (!empty($dataList)) {
        foreach ($dataList as $dataItem) {
            $result[$dataItem->id] = ['a' => $dataItem->a, 'b' => $dataItem->b];
        }
    }

    $cache->set($key, $result);
 
    return $result;
}
?>
```
3. Схематично описать структуру таблиц для хранения информации о медикаментах со следующими требованиями: лекарство имеет название, срок годности и список болезней, при которых это лекарство можно применять.

```
CREATE TABLE medicine (
    id int NOT NULL AUTO_INCREMENT,
    name varchar(100) NOT NULL,
    expiration_date DATE NULL,
    CONSTRAINT medicine_PK PRIMARY KEY (id)
)
ENGINE=InnoDB
DEFAULT CHARSET=utf8
COLLATE=utf8_general_ci;


CREATE TABLE disase (
    id int NOT NULL AUTO_INCREMENT,
    name varchar(100) NOT NULL,
    CONSTRAINT medicine_PK PRIMARY KEY (id)
)
ENGINE=InnoDB
DEFAULT CHARSET=utf8
COLLATE=utf8_general_ci;

CREATE TABLE skyeng.cure (
    medicine_id int NOT NULL,
    disase_id int NOT NULL,
    CONSTRAINT cure_medicine_FK FOREIGN KEY (medicine_id) REFERENCES skyeng.medicine(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT cure_disase_FK FOREIGN KEY (disase_id) REFERENCES skyeng.disase(id) ON DELETE CASCADE ON UPDATE CASCADE
)
ENGINE=InnoDB
DEFAULT CHARSET=utf8
COLLATE=utf8_general_ci;
```